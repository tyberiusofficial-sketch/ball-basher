<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Territory Clash</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #444;
      background: #000;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-family: monospace;
      font-size: 14px;
      color: #eee;
      text-align: center;
    }
    #controls {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
    }
    button {
      margin: 0 5px;
      padding: 5px 10px;
      background: #444;
      color: #eee;
      border: none;
      cursor: pointer;
    }
    button:hover { background: #666; }
    #winner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: monospace;
      font-size: 24px;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 8px;
      display: none;
      text-align: center;
    }
    #winner button {
      display: block;
      margin: 10px auto 0;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="hud">Day 0 | Light: 50% | Dark: 50%</div>
  <canvas id="game" width="400" height="400"></canvas>
  <div id="controls">
    <button onclick="toggle()">Start / Pause</button>
    <button onclick="resetGame()">Reset</button>
  </div>
  <div id="winner"></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Board + gameplay params
const GRID_SIZE   = 30;                // smaller → faster games
const CELL        = canvas.width / GRID_SIZE;
const BALL_RADIUS = 5;
const BITE_RADIUS = 3;
const BALL_SPEED  = 4;
const WIN_THRESH  = 5;                 // % remaining to lose

let running = false;
let frame   = 0;
let gameOver = false;

// Grid: 0 = light, 1 = dark
let grid = [];
function initGrid() {
  grid = new Array(GRID_SIZE);
  for (let y = 0; y < GRID_SIZE; y++) {
    grid[y] = new Array(GRID_SIZE);
    for (let x = 0; x < GRID_SIZE; x++) {
      grid[y][x] = (x < GRID_SIZE / 2) ? 0 : 1;
    }
  }
}

// Balls
let balls = [];

// Random direction at fixed speed
function randomDirection(speed) {
  const angle = Math.random() * Math.PI * 2;
  return { vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed };
}

// Reset
function resetGame() {
  initGrid();
  // spawn fixed x on each half, same y for now; random directions each round
  balls[0] = { x: 60,  y: 200, ...randomDirection(BALL_SPEED), side: 0 };
  balls[1] = { x: 340, y: 200, ...randomDirection(BALL_SPEED), side: 1 };
  running = false;
  frame   = 0;
  gameOver = false;
  document.getElementById("winner").style.display = "none";
  draw();
}

function toggle() {
  if (gameOver) return;
  running = !running;
  if (running) requestAnimationFrame(loop);
}

function loop() {
  if (!running) return;
  update();
  draw();
  frame++;
  if (!gameOver) requestAnimationFrame(loop);
}

// ---- Specular reflection helpers ----

// Estimate local frontier normal using central differences on the enemy mask.
// mask(x,y) = 1 if cell is enemy of the current ball, 0 otherwise.
function computeNormal(gx, gy, side) {
  function mask(x, y) {
    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return 0;
    return grid[y][x] !== side ? 1 : 0;
  }
  const left  = mask(gx - 1, gy);
  const right = mask(gx + 1, gy);
  const up    = mask(gx, gy - 1);
  const down  = mask(gx, gy + 1);

  // Gradient points across the boundary; its direction works for reflection either way.
  let nx = right - left;
  let ny = down - up;

  // If gradient is zero (rare—deep interior or perfectly symmetric corner),
  // try a simple 3x3 sample to break ties.
  if (nx === 0 && ny === 0) {
    let sx = 0, sy = 0;
    for (let j = -1; j <= 1; j++) {
      for (let i = -1; i <= 1; i++) {
        if (i === 0 && j === 0) continue;
        const m = mask(gx + i, gy + j);
        sx += m * i;
        sy += m * j;
      }
    }
    nx = sx; ny = sy;
  }

  const len = Math.hypot(nx, ny);
  if (len === 0) return null;
  return { nx: nx / len, ny: ny / len };
}

// Reflect velocity v about unit normal n: v' = v - 2 (v·n) n
function reflectVelocity(vx, vy, nx, ny) {
  const dot = vx * nx + vy * ny;
  return { vx: vx - 2 * dot * nx, vy: vy - 2 * dot * ny };
}

// -------------------------------------

function update() {
  balls.forEach(b => {
    b.x += b.vx;
    b.y += b.vy;

    // Wall bounce (perfectly specular on axis-aligned walls)
    if (b.x < BALL_RADIUS)  { b.x = BALL_RADIUS;  b.vx *= -1; }
    if (b.x > canvas.width - BALL_RADIUS) { b.x = canvas.width - BALL_RADIUS; b.vx *= -1; }
    if (b.y < BALL_RADIUS)  { b.y = BALL_RADIUS;  b.vy *= -1; }
    if (b.y > canvas.height - BALL_RADIUS) { b.y = canvas.height - BALL_RADIUS; b.vy *= -1; }

    // Enemy frontier collision
    const gx = Math.floor(b.x / CELL);
    const gy = Math.floor(b.y / CELL);
    if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
      if (grid[gy][gx] !== b.side) {
        // Take a bite
        carve(gx, gy, b.side);

        // Compute local frontier normal and reflect
        const n = computeNormal(gx, gy, b.side);
        if (n) {
          const r = reflectVelocity(b.vx, b.vy, n.nx, n.ny);
          b.vx = r.vx;
          b.vy = r.vy;
          // Nudge the ball along new direction to avoid sticking to boundary
          b.x += b.vx * 0.75;
          b.y += b.vy * 0.75;
        } else {
          // Fallback: flip both if we somehow didn't get a normal
          b.vx *= -1; b.vy *= -1;
          b.x += b.vx * 0.75;
          b.y += b.vy * 0.75;
        }
      }
    }
  });

  checkWinner();
}

function carve(cx, cy, side) {
  for (let dy = -BITE_RADIUS; dy <= BITE_RADIUS; dy++) {
    for (let dx = -BITE_RADIUS; dx <= BITE_RADIUS; dx++) {
      const x = cx + dx, y = cy + dy;
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) continue;
      if (dx * dx + dy * dy <= BITE_RADIUS * BITE_RADIUS) {
        grid[y][x] = side;
      }
    }
  }
}

function checkWinner() {
  const total = GRID_SIZE * GRID_SIZE;
  let light = 0, dark = 0;
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === 0) light++;
      else dark++;
    }
  }
  const lightPct = (light / total) * 100;
  const darkPct  = (dark  / total) * 100;

  if (lightPct < WIN_THRESH) endGame("Dark Wins!");
  else if (darkPct < WIN_THRESH) endGame("Light Wins!");
}

function endGame(message) {
  running = false;
  gameOver = true;
  const box = document.getElementById("winner");
  box.innerHTML = `<div>${message}</div><button onclick="resetGame()">Play Again</button>`;
  box.style.display = "block";
}

function draw() {
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      ctx.fillStyle = grid[y][x] === 0 ? "#d9e6e3" : "#163840";
      ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
    }
  }
  // Balls
  for (const b of balls) {
    ctx.beginPath();
    ctx.fillStyle = "#fff";
    ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
  }

  // HUD
  const total = GRID_SIZE * GRID_SIZE;
  let light = 0, dark = 0;
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (grid[y][x] === 0) light++; else dark++;
    }
  }
  document.getElementById("hud").textContent =
    `Day ${Math.floor(frame/60)} | Light: ${((light/total)*100).toFixed(1)}% | Dark: ${((dark/total)*100).toFixed(1)}%`;
}

// Start
resetGame();
</script>
</body>
</html>
